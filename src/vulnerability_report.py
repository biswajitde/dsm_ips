# -*- coding: utf-8 -*-
# Copyright Â© 2018 Trend Micro Incorporated.  All rights reserved.
"""Generate the Intrusion Prevention Vulnerability Report."""

import os
import csv
import configparser
from ds_utils import ds_utils

TMP_PATH = "../tmp"
NVD_PATH = "../nvd"
VULNERABILITY_PATH = "../vulnerabilities"
RESULT_PATH = "../results"

INPUT = "Azure_Scan_Results.xml"

REPORT_NAME = "Intrusion Prevention Vulnerability Report"

PROTECTED_STRING = "protected"
CAN_BE_PROTECTED_STRING = "can_be_protected"

def generate_vul_report(api_utils, cve_utils):
    """Generate the Intrusion Prevention Vulnerability Report."""

    # get the information of hosts
    hosts = api_utils.get_hosts()

    # get the host groups for classification
    host_groups = api_utils.get_host_groups()
    host_groups[None] = {'name': "Computers"}

    # get the information of Intrusion Prevention Rules
    ips_rules = ds_utils.CacheUtils.get_ips_rules(api_utils, TMP_PATH)

    # create a dictionary to store the mapping of CVEs and Intrusion Prevention Rule IDs
    cve_to_rule_id = cve_utils.get_cve_to_rule_id(ips_rules)

    # create a dictionary to store the mapping of CVEs and Intrusion Prevention Rule names
    cve_to_rule_name = cve_utils.get_cve_to_rule_name(ips_rules)

    # get the third party vulnerability report name
    config = configparser.ConfigParser()
    config.read('../config.ini')
    filename = config['Third Party Report']['third-party-report']

    # Import the third party vulnerability report
    report = ds_utils.CacheUtils.get_vulnerability_report(os.path.join(VULNERABILITY_PATH, filename), TMP_PATH)

    # import the NVD
    nvd = ds_utils.CacheUtils.get_nvd(NVD_PATH, TMP_PATH)
    need_nvd_update = False

    # loop all hosts to get protection status and information of vulnerabilities
    vuls = []
    progress_cnt = 0
    for host_id, host_info in hosts.items():
        if progress_cnt == len(hosts.items())-1:
            print("retrieving host data {0} / {1}".format(len(hosts.items()), len(hosts.items())))
        elif progress_cnt % 100 == 0:
            print("retrieving host data {0} / {1}".format(progress_cnt, len(hosts.items())))
        progress_cnt += 1
        
        # Deep Security Recommendation Scan return a list of Intrusion Prevention Rules,
        # A CVE may need multiple rules to protect.
        # On the other hand, a rule may be created for multiple CVEs.
        # We have to make sure that a CVE is actually vulnerable on the host,
        # i.e., all the rules corresponding to a CVE are remommended/assigned.

        # get all the CVEs protected by Deep Security Intrusion Prevention Rules
        assigned_rule_ids = api_utils.get_assigned_rule_ids_on_host(host_id)
        assigned_rule_id_set = set(assigned_rule_ids)
        protected_cves = []
        for assigned_rule_id in assigned_rule_ids:
            if ips_rules[str(assigned_rule_id)]['cves']:
                for cve in ips_rules[str(assigned_rule_id)]['cves']:
                    vulnerable = True
                    for rule_id in cve_to_rule_id[cve]:
                        if rule_id not in assigned_rule_id_set:
                            vulnerable = False

                    if vulnerable:
                        protected_cves.append(cve)
        protected_cves = set(protected_cves)

        # get all the CVEs reported by Qualys
        if host_info['name'] in report:
            for vul_info in report[host_info['name']]['vul_infos']:
                cve_id = vul_info['cve_id']
                details = {
                    'host_name': host_info['name'],
                    'host_group_name': host_groups[host_info['hostGroupID']]['name'],
                    'cve_id': cve_id,
                    'third_party': vul_info['third_party'],
                }
                if cve_id in protected_cves:
                    details['protection_status'] = PROTECTED_STRING
                elif cve_id in cve_to_rule_id:
                    details['protection_status'] = CAN_BE_PROTECTED_STRING

                vuls.append(details)

    # write the report
    if not os.path.exists(RESULT_PATH):
        os.makedirs(RESULT_PATH)
    with open(os.path.join(RESULT_PATH, REPORT_NAME + ".csv"), 'w', newline='') as file:
        writer = csv.writer(file)

        writer.writerow([REPORT_NAME])
        writer.writerow([])
        writer.writerow(["# This report shows information based on scan results from third-party vulnerability scanners."])
        writer.writerow(["# It displays the unprotected CVEs on your hosts that you can protect against by assigning additional rules."])
        writer.writerow(["# It also lists the CVEs that currently assigned rules are protecting against."])
        writer.writerow([])

        writer.writerow(["Hosts", "Total Number of Hosts"])
        if len(hosts) > 100:
            writer.writerow(['; '.join([host_info['name'] for host_id, host_info in hosts.items()][:100]) + ", ...", len(hosts)])
        else:
            writer.writerow(['; '.join([host_info['name'] for host_id, host_info in hosts.items()]), len(hosts)])
        writer.writerow([])

        severity_dict = {
            ds_utils.CVE_SEVERITY_CRITICAL: 0,
            ds_utils.CVE_SEVERITY_HIGH: 0,
            ds_utils.CVE_SEVERITY_MEDIUM: 0,
            ds_utils.CVE_SEVERITY_LOW: 0,
            ds_utils.CVE_SEVERITY_NONE: 0,
            ds_utils.CVE_SEVERITY_UNKOWN: 0
        }
        cnt = {PROTECTED_STRING: severity_dict.copy(), CAN_BE_PROTECTED_STRING: severity_dict.copy()}
        vul_rows = {PROTECTED_STRING: [], CAN_BE_PROTECTED_STRING: []}
        for vul in vuls:
            cve_id = vul['cve_id']
            if cve_id not in nvd:
                need_nvd_update = True
                continue

            vul_row = [
                cve_id,
                vul['host_name'],
                vul['host_group_name'],
                nvd[cve_id]['cvssVersion'],
                nvd[cve_id]['severity'],
                nvd[cve_id]['baseScore'],
                nvd[cve_id]['vectorString'],
                ', '.join(cve_to_rule_name[cve_id])
            ]
            for key, value in vul['third_party'].items():
                vul_row.append(value)

            if 'protection_status' in vul:
                if vul['protection_status'] == PROTECTED_STRING:
                    cnt[PROTECTED_STRING][nvd[cve_id]['severity']] += 1
                    vul_rows[PROTECTED_STRING].append(vul_row)
                elif vul['protection_status'] == CAN_BE_PROTECTED_STRING:
                    cnt[CAN_BE_PROTECTED_STRING][nvd[cve_id]['severity']] += 1
                    vul_rows[CAN_BE_PROTECTED_STRING].append(vul_row)

        writer.writerow(["CVEs already protected (Based on severity level)"])
        for severity, _ in severity_dict.items():
            if cnt[PROTECTED_STRING][severity] + cnt[CAN_BE_PROTECTED_STRING][severity] > 0:
                writer.writerow([
                    "{0}: {1:.2f}% ({2}/{3})".format(
                        severity,
                        cnt[PROTECTED_STRING][severity]/(cnt[PROTECTED_STRING][severity]+cnt[CAN_BE_PROTECTED_STRING][severity])*100,
                        cnt[PROTECTED_STRING][severity],
                        cnt[PROTECTED_STRING][severity]+cnt[CAN_BE_PROTECTED_STRING][severity]
                    )
                ])
        writer.writerow([])

        writer.writerow(["CVEs that can be protected (Based on severity level)"])
        for severity, _ in severity_dict.items():
            if cnt[PROTECTED_STRING][severity] + cnt[CAN_BE_PROTECTED_STRING][severity] > 0:
                writer.writerow([
                    "{0}: {1:.2f}% ({2}/{3})".format(
                        severity,
                        cnt[CAN_BE_PROTECTED_STRING][severity]/(cnt[PROTECTED_STRING][severity]+cnt[CAN_BE_PROTECTED_STRING][severity])*100,
                        cnt[CAN_BE_PROTECTED_STRING][severity],
                        cnt[PROTECTED_STRING][severity]+cnt[CAN_BE_PROTECTED_STRING][severity]
                    )
                ])
        writer.writerow([])

        writer.writerow(["Call to action [How to assign rules: https://help.deepsecurity.trendmicro.com/Protection-Modules/Intrusion-Prevention/ui-policies-rules-ip.html#Assignin]"])
        writer.writerow([])

        header = [
            "CVE ID",
            "Host",
            "Host Group",
            "CVSS version",
            "Severity",
            "CVSS Base Score",
            "Vector String",
            "Rule Name"
        ]
        if vuls:
            for key in vuls[0]['third_party'].keys():
                key = key[0].upper() + key[1:]
                header.append(key)

        writer.writerow(["CVEs already protected on Hosts"])
        if vul_rows[PROTECTED_STRING]:
            writer.writerow(header)
            for row in vul_rows[PROTECTED_STRING]:
                writer.writerow(row)
        writer.writerow([])

        writer.writerow(["CVEs that can be protected on Hosts"])
        if vul_rows[CAN_BE_PROTECTED_STRING]:
            writer.writerow(header)
            for row in vul_rows[CAN_BE_PROTECTED_STRING]:
                writer.writerow(row)

        if need_nvd_update:
            print("Please update the NVD")

def main():
    """Main function"""

    # generate the report
    # use "with" statement to automatically end the session after API calls
    with ds_utils.APIUtils() as api_utils:
        cve_utils = ds_utils.CVEUtils()
        generate_vul_report(api_utils, cve_utils)


if __name__ == "__main__":
    main()
